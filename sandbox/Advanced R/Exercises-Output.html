<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Exercises from Data-structures.rmd</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h4>Exercises from Data-structures.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>What are the six types of atomic vector? How does a list differ from an
atomic vector?</p></li>
<li><p>What makes <code>is.vector()</code> and <code>is.numeric()</code> fundamentally different to
<code>is.list()</code> and <code>is.character()</code>?</p></li>
<li><p>Test your knowledge of vector coercion rules by predicting the output of
the following uses of <code>c()</code>:</p>

<pre><code class="r">c(1, FALSE)
c(&quot;a&quot;, 1)
c(list(1), &quot;a&quot;)
c(TRUE, 1L)
</code></pre></li>
<li><p>Why do you need to use <code>unlist()</code> to convert a list to an 
atomic vector? Why doesn&#39;t <code>as.vector()</code> work? </p></li>
<li><p>Why is <code>1 == &quot;1&quot;</code> true? Why is <code>-1 &lt; FALSE</code> true? Why is <code>&quot;one&quot; &lt; 2</code> false?</p></li>
<li><p>Why is the default missing value, <code>NA</code>, a logical vector? What&#39;s special
about logical vectors? (Hint: think about <code>c(FALSE, NA_character_)</code>.)</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>An early draft used this code to illustrate <code>structure()</code>:</p>

<pre><code class="r">structure(1:5, comment = &quot;my attribute&quot;)
</code></pre>

<pre><code>## [1] 1 2 3 4 5
</code></pre>

<p>But when you print that object you don&#39;t see the comment attribute.
Why? Is the attribute missing, or is there something else special about
it? (Hint: try using help.) \index{attributes!comment}</p></li>
<li><p>What happens to a factor when you modify its levels? </p>

<pre><code class="r">f1 &lt;- factor(letters)
levels(f1) &lt;- rev(levels(f1))
</code></pre></li>
<li><p>What does this code do? How do <code>f2</code> and <code>f3</code> differ from <code>f1</code>?</p>

<pre><code class="r">f2 &lt;- rev(factor(letters))

f3 &lt;- factor(letters, levels = rev(letters))
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>What does <code>dim()</code> return when applied to a vector?</p></li>
<li><p>If <code>is.matrix(x)</code> is <code>TRUE</code>, what will <code>is.array(x)</code> return?</p></li>
<li><p>How would you describe the following three objects? What makes them
different to <code>1:5</code>?</p>

<pre><code class="r">x1 &lt;- array(1:5, c(1, 1, 5))
x2 &lt;- array(1:5, c(1, 5, 1))
x3 &lt;- array(1:5, c(5, 1, 1))
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>What attributes does a data frame possess?</p></li>
<li><p>What does <code>as.matrix()</code> do when applied to a data frame with 
columns of different types?</p></li>
<li><p>Can you have a data frame with 0 rows? What about 0 columns?</p></li>
</ol>

<h4>Exercises from Subsetting.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>Fix each of the following common data frame subsetting errors:</p>

<pre><code class="r">mtcars[mtcars$cyl = 4, ]
mtcars[-1:4, ]
mtcars[mtcars$cyl &lt;= 5]
mtcars[mtcars$cyl == 4 | 6, ]
</code></pre></li>
<li><p>Why does <code>x &lt;- 1:5; x[NA]</code> yield five missing values? (Hint: why is 
it different from <code>x[NA_real_]</code>?)</p></li>
<li><p>What does <code>upper.tri()</code> return? How does subsetting a matrix with it 
work? Do we need any additional subsetting rules to describe its behaviour?</p>

<pre><code class="r">x &lt;- outer(1:5, 1:5, FUN = &quot;*&quot;)
x[upper.tri(x)]
</code></pre></li>
<li><p>Why does <code>mtcars[1:20]</code> return an error? How does it differ from the 
similar <code>mtcars[1:20, ]</code>?</p></li>
<li><p>Implement your own function that extracts the diagonal entries from a
matrix (it should behave like <code>diag(x)</code> where <code>x</code> is a matrix).</p></li>
<li><p>What does <code>df[is.na(df)] &lt;- 0</code> do? How does it work?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li> Given a linear model, e.g., <code>mod &lt;- lm(mpg ~ wt, data = mtcars)</code>, extract
the residual degrees of freedom. Extract the R squared from the model
summary (<code>summary(mod)</code>)</li>
</ol>

<!-- FIXME: more examples -->

<h3>Exercises</h3>

<ol>
<li><p>How would you randomly permute the columns of a data frame? (This is an
important technique in random forests.) Can you simultaneously permute 
the rows and columns in one step?</p></li>
<li><p>How would you select a random sample of <code>m</code> rows from a data frame? 
What if the sample had to be contiguous (i.e., with an initial row, a 
final row, and every row in between)?</p></li>
<li><p>How could you put the columns in a data frame in alphabetical order?</p></li>
</ol>

<h4>Exercises from Functions.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>What function allows you to tell if an object is a function? What function
allows you to tell if a function is a primitive function?</p></li>
<li><p>This code makes a list of all functions in the base package. </p>

<pre><code class="r">objs &lt;- mget(ls(&quot;package:base&quot;), inherits = TRUE)
funs &lt;- Filter(is.function, objs)
</code></pre>

<p>Use it to answer the following questions:</p>

<p>a. Which base function has the most arguments?</p>

<p>a. How many base functions have no arguments? What&#39;s special about those
   functions?</p>

<p>a. How could you adapt the code to find all primitive functions?</p></li>
<li><p>What are the three important components of a function?</p></li>
<li><p>When does printing a function not show what environment it was created in?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>What does the following code return? Why? What does each of the three <code>c</code>&#39;s mean?</p>

<pre><code class="r">c &lt;- 10
c(c = c)
</code></pre></li>
<li><p>What are the four principles that govern how R looks for values?</p></li>
<li><p>What does the following function return? Make a prediction before 
running the code yourself.</p>

<pre><code class="r">f &lt;- function(x) {
  f &lt;- function(x) {
    f &lt;- function(x) {
      x ^ 2
    }
    f(x) + 1
  }
  f(x) * 2
}
f(10)
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Clarify the following list of odd function calls:</p>

<pre><code class="r">x &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))
y &lt;- runif(min = 0, max = 1, 20)
cor(m = &quot;k&quot;, y = y, u = &quot;p&quot;, x = x)
</code></pre></li>
<li><p>What does this function return? Why? Which principle does it illustrate?</p>

<pre><code class="r">f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) {
  x + y
}
f1()
</code></pre></li>
<li><p>What does this function return? Why? Which principle does it illustrate?</p>

<pre><code class="r">f2 &lt;- function(x = z) {
  z &lt;- 100
  x
}
f2()
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Create a list of all the replacement functions found in the base package. 
Which ones are primitive functions?</p></li>
<li><p>What are valid names for user-created infix functions?</p></li>
<li><p>Create an infix <code>xor()</code> operator.</p></li>
<li><p>Create infix versions of the set functions <code>intersect()</code>, <code>union()</code>, and 
<code>setdiff()</code>.</p></li>
<li><p>Create a replacement function that modifies a random location in a vector.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>How does the <code>chdir</code> parameter of <code>source()</code> compare to <code>in_dir()</code>? Why 
might you prefer one approach to the other?</p></li>
<li><p>What function undoes the action of <code>library()</code>? How do you save and restore
the values of <code>options()</code> and <code>par()</code>?</p></li>
<li><p>Write a function that opens a graphics device, runs the supplied code, and 
closes the graphics device (always, regardless of whether or not the plotting 
code worked).</p></li>
<li><p>We can use <code>on.exit()</code> to implement a simple version of <code>capture.output()</code>.</p>

<pre><code class="r">capture.output2 &lt;- function(code) {
  temp &lt;- tempfile()
  on.exit(file.remove(temp), add = TRUE)

  sink(temp)
  on.exit(sink(), add = TRUE)

  force(code)
  readLines(temp)
}
capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\n&quot;))
</code></pre>

<pre><code>## Warning in file.remove(temp): cannot remove file &#39;C:\Users\richad\AppData
## \Local\Temp\Rtmpo9rWyi\file101843d26f7&#39;, reason &#39;Permission denied&#39;
</code></pre>

<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
</code></pre>

<p>Compare <code>capture.output()</code> to <code>capture.output2()</code>. How do the functions 
differ? What features have I removed to make the key ideas easier to see? 
How have I rewritten the key ideas to be easier to understand?</p></li>
</ol>

<h4>Exercises from OO-essentials.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>Read the source code for <code>t()</code> and <code>t.test()</code> and confirm that 
<code>t.test()</code> is an S3 generic and not an S3 method. What happens if 
you create an object with class <code>test</code> and call <code>t()</code> with it?</p></li>
<li><p>What classes have a method for the <code>Math</code> group generic in base R? Read 
the source code. How do the methods work?</p></li>
<li><p>R has two classes for representing date time data, <code>POSIXct</code> and 
<code>POSIXlt</code>, which both inherit from <code>POSIXt</code>. Which generics have 
different behaviours for the two classes? Which generics share the same
behaviour?</p></li>
<li><p>Which base generic has the greatest number of defined methods?</p></li>
<li><p><code>UseMethod()</code> calls methods in a special way. Predict what the following
 code will return, then run it and read the help for <code>UseMethod()</code> to 
figure out what&#39;s going on. Write down the rules in the simplest form
possible.</p>

<pre><code class="r">y &lt;- 1
g &lt;- function(x) {
  y &lt;- 2
  UseMethod(&quot;g&quot;)
}
g.numeric &lt;- function(x) y
g(10)

h &lt;- function(x) {
  x &lt;- 10
  UseMethod(&quot;h&quot;)
}
h.character &lt;- function(x) paste(&quot;char&quot;, x)
h.numeric &lt;- function(x) paste(&quot;num&quot;, x)

h(&quot;a&quot;)
</code></pre></li>
<li><p>Internal generics don&#39;t dispatch on the implicit class of base types.
Carefully read <code>?&quot;internal generic&quot;</code> to determine why the length of <code>f</code> 
and <code>g</code> is different in the example below. What function helps 
distinguish between the behaviour of <code>f</code> and <code>g</code>?</p>

<pre><code class="r">f &lt;- function() 1
g &lt;- function() 2
class(g) &lt;- &quot;function&quot;

class(f)
class(g)

length.function &lt;- function(x) &quot;function&quot;
length(f)
length(g)
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Which S4 generic has the most methods defined for it? Which S4 class 
has the most methods associated with it?</p></li>
<li><p>What happens if you define a new S4 class that doesn&#39;t &ldquo;contain&rdquo; an 
existing class?  (Hint: read about virtual classes in <code>?Classes</code>.)</p></li>
<li><p>What happens if you pass an S4 object to an S3 generic? What happens 
if you pass an S3 object to an S4 generic? (Hint: read <code>?setOldClass</code> 
for the second case.)</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Use a field function to prevent the account balance from being directly
manipulated. (Hint: create a &ldquo;hidden&rdquo; <code>.balance</code> field, and read the 
help for the fields argument in <code>setRefClass()</code>.)</p></li>
<li><p>I claimed that there aren&#39;t any RC classes in base R, but that was a 
bit of a simplification. Use <code>getClasses()</code> and find which classes 
<code>extend()</code> from <code>envRefClass</code>. What are the classes used for? (Hint: 
recall how to look up the documentation for a class.)</p></li>
</ol>

<h4>Exercises from Environments.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>List three ways in which an environment differs from a list.</p></li>
<li><p>If you don&#39;t supply an explicit environment, where do <code>ls()</code> and <code>rm()</code>
look? Where does <code>&lt;-</code> make bindings?</p></li>
<li><p>Using <code>parent.env()</code> and a loop (or a recursive function), verify that the 
ancestors of <code>globalenv()</code> include <code>baseenv()</code> and <code>emptyenv()</code>. Use the 
same basic idea to implement your own version of <code>search()</code>.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Modify <code>where()</code> to find all environments that contain a binding for
<code>name</code>.</p></li>
<li><p>Write your own version of <code>get()</code> using a function written in the style 
of <code>where()</code>.</p></li>
<li><p>Write a function called <code>fget()</code> that finds only function objects. It 
should have two arguments, <code>name</code> and <code>env</code>, and should obey the regular 
scoping rules for functions: if there&#39;s an object with a matching name 
that&#39;s not a function, look in the parent. For an added challenge, also 
add an <code>inherits</code> argument which controls whether the function recurses up 
the parents or only looks in one environment.</p></li>
<li><p>Write your own version of <code>exists(inherits = FALSE)</code> (Hint: use <code>ls()</code>.) 
Write a recursive version that behaves like <code>exists(inherits = TRUE)</code>.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>List the four environments associated with a function. What does each one
do? Why is the distinction between enclosing and binding environments
particularly important?</p></li>
<li><p>Draw a diagram that shows the enclosing environments of this function:</p>

<pre><code class="r">f1 &lt;- function(x1) {
  f2 &lt;- function(x2) {
    f3 &lt;- function(x3) {
      x1 + x2 + x3
    }
    f3(3)
  }
  f2(2)
}
f1(1)
</code></pre></li>
<li><p>Expand your previous diagram to show function bindings.</p></li>
<li><p>Expand it again to show the execution and calling environments.</p></li>
<li><p>Write an enhanced version of <code>str()</code> that provides more information 
about functions. Show where the function was found and what environment 
it was defined in.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>What does this function do? How does it differ from <code>&lt;&lt;-</code> and why
might you prefer it?</p>

<pre><code class="r">rebind &lt;- function(name, value, env = parent.frame()) {
  if (identical(env, emptyenv())) {
    stop(&quot;Can&#39;t find &quot;, name, call. = FALSE)
  } else if (exists(name, envir = env, inherits = FALSE)) {
    assign(name, value, envir = env)
  } else {
    rebind(name, value, parent.env(env))
  }
}
rebind(&quot;a&quot;, 10)
</code></pre>

<pre><code>## Error: Can&#39;t find a
</code></pre>

<pre><code class="r">a &lt;- 5
rebind(&quot;a&quot;, 10)
a
</code></pre>

<pre><code>## [1] 10
</code></pre></li>
<li><p>Create a version of <code>assign()</code> that will only bind new names, never 
re-bind old names. Some programming languages only do this, and are known 
as [single assignment languages][single assignment].</p></li>
<li><p>Write an assignment function that can do active, delayed, and locked 
bindings. What might you call it? What arguments should it take? Can you 
guess which sort of assignment it should do based on the input?</p></li>
</ol>

<h4>Exercises from Exceptions-Debugging.rmd</h4>

<h3>Exercises</h3>

<ul>
<li><p>Compare the following two implementations of <code>message2error()</code>. What is the
main advantage of <code>withCallingHandlers()</code> in this scenario? (Hint: look
carefully at the traceback.)</p>

<pre><code class="r">message2error &lt;- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}
message2error &lt;- function(code) {
  tryCatch(code, message = function(e) stop(e))
}
</code></pre></li>
</ul>

<h3>Exercises</h3>

<ul>
<li><p>The goal of the <code>col_means()</code> function defined below is to compute the means
of all numeric columns in a data frame.</p>

<pre><code class="r">col_means &lt;- function(df) {
  numeric &lt;- sapply(df, is.numeric)
  numeric_cols &lt;- df[, numeric]

  data.frame(lapply(numeric_cols, mean))
}
</code></pre>

<p>However, the function is not robust to unusual inputs. Look at
the following results, decide which ones are incorrect, and modify
<code>col_means()</code> to be more robust. (Hint: there are two function calls
in <code>col_means()</code> that are particularly prone to problems.)</p>

<pre><code class="r">col_means(mtcars)
col_means(mtcars[, 0])
col_means(mtcars[0, ])
col_means(mtcars[, &quot;mpg&quot;, drop = F])
col_means(1:10)
col_means(as.matrix(mtcars))
col_means(as.list(mtcars))

mtcars2 &lt;- mtcars
mtcars2[-1] &lt;- lapply(mtcars2[-1], as.character)
col_means(mtcars2)
</code></pre></li>
<li><p>The following function &ldquo;lags&rdquo; a vector, returning a version of <code>x</code> that is <code>n</code>
values behind the original. Improve the function so that it (1) returns a
useful error message if <code>n</code> is not a vector, and (2) has reasonable behaviour
when <code>n</code> is 0 or longer than <code>x</code>.</p>

<pre><code class="r">lag &lt;- function(x, n = 1L) {
  xlen &lt;- length(x)
  c(rep(NA, n), x[seq_len(xlen - n)])
}
</code></pre></li>
</ul>

<h4>Exercises from Functional-programming.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>Given a function, like <code>&quot;mean&quot;</code>, <code>match.fun()</code> lets you find a function. 
Given a function, can you find its name? Why doesn&#39;t that make sense in R?</p></li>
<li><p>Use <code>lapply()</code> and an anonymous function to find the coefficient of 
variation (the standard deviation divided by the mean) for all columns in 
the <code>mtcars</code> dataset.</p></li>
<li><p>Use <code>integrate()</code> and an anonymous function to find the area under the 
curve for the following functions. 
Use <a href="http://www.wolframalpha.com/">Wolfram Alpha</a> to check your answers.</p>

<ol>
<li><code>y = x ^ 2 - x</code>, x in [0, 10]</li>
<li><code>y = sin(x) + cos(x)</code>, x in [-\(\pi\), \(\pi\)]</li>
<li><code>y = exp(x) / x</code>, x in [10, 20]</li>
</ol></li>
<li><p>A good rule of thumb is that an anonymous function should fit on one line 
and shouldn&#39;t need to use <code>{}</code>. Review your code. Where could you have 
used an anonymous function instead of a named function? Where should you 
have used a named function instead of an anonymous function?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Why are functions created by other functions called closures? </p></li>
<li><p>What does the following statistical function do? What would be a better 
name for it? (The existing name is a bit of a hint.)</p>

<pre><code class="r">bc &lt;- function(lambda) {
  if (lambda == 0) {
    function(x) log(x)
  } else {
    function(x) (x ^ lambda - 1) / lambda
  }
}
</code></pre></li>
<li><p>What does <code>approxfun()</code> do? What does it return?</p></li>
<li><p>What does <code>ecdf()</code> do? What does it return?</p></li>
<li><p>Create a function that creates functions that compute the ith 
<a href="http://en.wikipedia.org/wiki/Central_moment">central moment</a> of a numeric 
vector. You can test it by running the following code:</p>

<pre><code class="r">m1 &lt;- moment(1)
m2 &lt;- moment(2)

x &lt;- runif(100)
stopifnot(all.equal(m1(x), 0))
stopifnot(all.equal(m2(x), var(x) * 99 / 100))
</code></pre></li>
<li><p>Create a function <code>pick()</code> that takes an index, <code>i</code>, as an argument and 
returns a function with an argument <code>x</code> that subsets <code>x</code> with <code>i</code>.</p>

<pre><code class="r">lapply(mtcars, pick(5))
# should do the same as this
lapply(mtcars, function(x) x[[5]])
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Implement a summary function that works like <code>base::summary()</code>, but uses a 
list of functions. Modify the function so it returns a closure, making it 
possible to use it as a function factory.</p></li>
<li><p>Which of the following commands is equivalent to <code>with(x, f(z))</code>?</p>

<p>(a) <code>x$f(x$z)</code>.
(b) <code>f(x$z)</code>.
&copy; <code>x$f(z)</code>.
(d) <code>f(z)</code>.
(e) It depends.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Instead of creating individual functions (e.g., <code>midpoint()</code>, 
  <code>trapezoid()</code>, <code>simpson()</code>, etc.), we could store them in a list. If we 
did that, how would that change the code? Can you create the list of 
functions from a list of coefficients for the Newton-Cotes formulae?</p></li>
<li><p>The trade-off between integration rules is that more complex rules are 
slower to compute, but need fewer pieces. For <code>sin()</code> in the range 
[0, \(\pi\)], determine the number of pieces needed so that each rule will 
be equally accurate. Illustrate your results with a graph. How do they
change for different functions? <code>sin(1 / x^2)</code> is particularly challenging.</p></li>
</ol>

<h4>Exercises from Functionals.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>Why are the following two invocations of <code>lapply()</code> equivalent?</p>

<pre><code class="r">trims &lt;- c(0, 0.1, 0.2, 0.5)
x &lt;- rcauchy(100)

lapply(trims, function(trim) mean(x, trim = trim))
lapply(trims, mean, x = x)
</code></pre></li>
<li><p>The function below scales a vector so it falls in the range [0, 1]. How
would you apply it to every column of a data frame? How would you apply it 
to every numeric column in a data frame?</p>

<pre><code class="r">scale01 &lt;- function(x) {
  rng &lt;- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
</code></pre></li>
<li><p>Use both for loops and <code>lapply()</code> to fit linear models to the
<code>mtcars</code> using the formulas stored in this list:</p>

<pre><code class="r">formulas &lt;- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)
</code></pre></li>
<li><p>Fit the model <code>mpg ~ disp</code> to each of the bootstrap replicates of <code>mtcars</code> 
in the list below by using a for loop and <code>lapply()</code>. Can you do it 
without an anonymous function?</p>

<pre><code class="r">bootstraps &lt;- lapply(1:10, function(i) {
  rows &lt;- sample(1:nrow(mtcars), rep = TRUE)
  mtcars[rows, ]
})
</code></pre></li>
<li><p>For each model in the previous two exercises, extract \(R^2\) using the
function below.</p>

<pre><code class="r">rsq &lt;- function(mod) summary(mod)$r.squared
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Use <code>vapply()</code> to:</p>

<p>a) Compute the standard deviation of every column in a numeric data frame.</p>

<p>a) Compute the standard deviation of every numeric column in a mixed data
   frame. (Hint: you&#39;ll need to use <code>vapply()</code> twice.)</p></li>
<li><p>Why is using <code>sapply()</code> to get the <code>class()</code> of each element in 
a data frame dangerous?</p></li>
<li><p>The following code simulates the performance of a t-test for non-normal 
data. Use <code>sapply()</code> and an anonymous function to extract the p-value from 
every trial.</p>

<pre><code class="r">trials &lt;- replicate(
  100, 
  t.test(rpois(10, 10), rpois(7, 10)),
  simplify = FALSE
)
</code></pre>

<p>Extra challenge: get rid of the anonymous function by using <code>[[</code> directly.</p></li>
<li><p>What does <code>replicate()</code> do? What sort of for loop does it eliminate? Why 
do its arguments differ from <code>lapply()</code> and friends?</p></li>
<li><p>Implement a version of <code>lapply()</code> that supplies <code>FUN</code> with both the name 
and the value of each component.</p></li>
<li><p>Implement a combination of <code>Map()</code> and <code>vapply()</code> to create an <code>lapply()</code>
variant that iterates in parallel over all of its inputs and stores its 
outputs in a vector (or a matrix). What arguments should the function 
take?</p></li>
<li><p>Implement <code>mcsapply()</code>, a multicore version of <code>sapply()</code>. Can you
implement <code>mcvapply()</code>, a parallel version of <code>vapply()</code>? Why or why not?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>How does <code>apply()</code> arrange the output? Read the documentation and perform 
some experiments.</p></li>
<li><p>There&#39;s no equivalent to <code>split()</code> + <code>vapply()</code>. Should there be? When 
would it be useful? Implement one yourself.</p></li>
<li><p>Implement a pure R version of <code>split()</code>. (Hint: use <code>unique()</code> and 
subsetting.) Can you do it without a for loop?</p></li>
<li><p>What other types of input and output are missing? Brainstorm before you 
look up some answers in the <a href="http://www.jstatsoft.org/v40/i01/">plyr paper</a>.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Why isn&#39;t <code>is.na()</code> a predicate function? What base R function is closest
to being a predicate version of <code>is.na()</code>?</p></li>
<li><p>Use <code>Filter()</code> and <code>vapply()</code> to create a function that applies a summary 
statistic to every numeric column in a data frame.</p></li>
<li><p>What&#39;s the relationship between <code>which()</code> and <code>Position()</code>? What&#39;s
the relationship between <code>where()</code> and <code>Filter()</code>?</p></li>
<li><p>Implement <code>Any()</code>, a function that takes a list and a predicate function, 
and returns <code>TRUE</code> if the predicate function returns <code>TRUE</code> for any of 
the inputs. Implement <code>All()</code> similarly.</p></li>
<li><p>Implement the <code>span()</code> function from Haskell: given a list <code>x</code> and a 
predicate function <code>f</code>, <code>span</code> returns the location of the longest 
sequential run of elements where the predicate is true. (Hint: you 
might find <code>rle()</code> helpful.)</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Implement <code>arg_max()</code>. It should take a function and a vector of inputs, 
and return the elements of the input where the function returns the highest 
value. For example, <code>arg_max(-10:5, function(x) x ^ 2)</code> should return -10.
<code>arg_max(-5:5, function(x) x ^ 2)</code> should return <code>c(-5, 5)</code>.
Also implement the matching <code>arg_min()</code> function.</p></li>
<li><p>Challenge: read about the 
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3">fixed point algorithm</a>. 
Complete the exercises using R.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Implement <code>smaller</code> and <code>larger</code> functions that, given two inputs, return 
either the smaller or the larger value. Implement <code>na.rm = TRUE</code>: what 
should the identity be? (Hint: 
<code>smaller(x, smaller(NA, NA, na.rm = TRUE), na.rm = TRUE)</code> must be <code>x</code>, so 
<code>smaller(NA, NA, na.rm = TRUE)</code> must be bigger than any other value of x.) 
Use <code>smaller</code> and <code>larger</code> to implement equivalents of <code>min()</code>, <code>max()</code>,
<code>pmin()</code>, <code>pmax()</code>, and new functions <code>row_min()</code> and <code>row_max()</code>.</p></li>
<li><p>Create a table that has <em>and</em>, <em>or</em>, <em>add</em>, <em>multiply</em>, <em>smaller</em>, and 
<em>larger</em> in the columns and <em>binary operator</em>, <em>reducing variant</em>, 
<em>vectorised variant</em>, and <em>array variants</em> in the rows.</p>

<p>a) Fill in the cells with the names of base R functions that perform each of
   the roles.</p>

<p>a) Compare the names and arguments of the existing R functions. How
   consistent are they? How could you improve them?</p>

<p>a) Complete the matrix by implementing any missing functions.</p></li>
<li><p>How does <code>paste()</code> fit into this structure? What is the scalar binary 
function that underlies <code>paste()</code>? What are the <code>sep</code> and <code>collapse</code> 
arguments to <code>paste()</code> equivalent to? Are there any <code>paste</code> variants 
that don&#39;t have existing R implementations?</p></li>
</ol>

<h4>Exercises from Function-operators.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>Write a FO that logs a time stamp and message to a file every time a 
function is run.</p></li>
<li><p>What does the following function do? What would be a good name for it?</p>

<pre><code class="r">f &lt;- function(g) {
  force(g)
  result &lt;- NULL
  function(...) {
    if (is.null(result)) {
      result &lt;&lt;- g(...)
    }
    result
  }
}
runif2 &lt;- f(runif)
runif2(5)
</code></pre>

<pre><code>## [1] 0.217871178 0.253902283 0.007120247 0.992469056 0.363025261
</code></pre>

<pre><code class="r">runif2(10)
</code></pre>

<pre><code>## [1] 0.217871178 0.253902283 0.007120247 0.992469056 0.363025261
</code></pre></li>
<li><p>Modify <code>delay_by()</code> so that instead of delaying by a fixed amount of time, 
it ensures that a certain amount of time has elapsed since the function 
was last called. That is, if you called 
<code>g &lt;- delay_by(1, f); g(); Sys.sleep(2); g()</code> there shouldn&#39;t be an 
extra delay.</p></li>
<li><p>Write <code>wait_until()</code> which delays execution until a specific time.</p></li>
<li><p>There are three places we could have added a memoise call: why did we 
choose the one we did?</p>

<pre><code class="r">download &lt;- memoise(dot_every(10, delay_by(1, download_file)))
download &lt;- dot_every(10, memoise(delay_by(1, download_file)))
download &lt;- dot_every(10, delay_by(1, memoise(download_file)))
</code></pre></li>
<li><p>Why is the <code>remember()</code> function inefficient? How could you implement it 
in more efficient way?</p></li>
<li><p>Why does the following code, from 
<a href="http://stackoverflow.com/questions/8440675">stackoverflow</a>, not do what you expect?</p>

<pre><code class="r"># return a linear function with slope a and intercept b.
f &lt;- function(a, b) function(x) a * x + b

# create a list of functions with different parameters.
fs &lt;- Map(f, a = c(0, 1), b = c(0, 1))

fs[[1]](3)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<pre><code class="r"># should return 0 * 3 + 0 = 0
</code></pre>

<p>How can you modify <code>f</code> so that it works correctly?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Create a <code>negative()</code> FO that flips the sign of the output of the 
function to which it is applied.</p></li>
<li><p>The <code>evaluate</code> package makes it easy to capture all the outputs (results, 
text, messages, warnings, errors, and plots) from an expression. Create a 
function like <code>capture_it()</code> that also captures the warnings and errors 
generated by a function.</p></li>
<li><p>Create a FO that tracks files created or deleted in the working directory 
(Hint: use <code>dir()</code> and <code>setdiff()</code>.) What other global effects of 
functions might you want to track?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Our previous <code>download()</code> function only downloads a single file. How can 
you use <code>partial()</code> and <code>lapply()</code> to create a function that downloads 
multiple files at once? What are the pros and cons of using <code>partial()</code> vs. 
writing a function by hand?</p></li>
<li><p>Read the source code for <code>plyr::colwise()</code>. How does the code work? What 
are <code>colwise()</code>&#39;s three main tasks? How could you make <code>colwise()</code> simpler 
by implementing each task as a function operator? (Hint: think about 
<code>partial()</code>.)</p></li>
<li><p>Write FOs that convert a function to return a matrix instead of a data 
frame, or a data frame instead of a matrix. If you understand S3, 
call them <code>as.data.frame.function()</code> and <code>as.matrix.function()</code>.</p></li>
<li><p>You&#39;ve seen five functions that modify a function to change its output 
from one form to another. What are they? Draw a table of the various 
combinations of types of outputs: what should go in the rows and what 
should go in the columns? What function operators might you want to write 
to fill in the missing cells? Come up with example use cases.</p></li>
<li><p>Look at all the examples of using an anonymous function to partially 
apply a function in this and the previous chapter. Replace the anonymous 
function with <code>partial()</code>. What do you think of the result? Is it easier or 
harder to read?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Implement your own version of <code>compose()</code> using <code>Reduce</code> and <code>%o%</code>. For 
bonus points, do it without calling <code>function</code>.</p></li>
<li><p>Extend <code>and()</code> and <code>or()</code> to deal with any number of input functions. Can 
you do it with <code>Reduce()</code>? Can you keep them lazy (e.g., for <code>and()</code>, the 
function returns once it sees the first <code>FALSE</code>)?</p></li>
<li><p>Implement the <code>xor()</code> binary operator. Implement it using the existing 
<code>xor()</code> function. Implement it as a combination of <code>and()</code> and <code>or()</code>. What 
are the advantages and disadvantages of each approach? Also think about 
what you&#39;ll call the resulting function to avoid a clash with the existing
<code>xor()</code> function, and how you might change the names of <code>and()</code>, <code>not()</code>, 
and <code>or()</code> to keep them consistent.</p></li>
<li><p>Above, we implemented boolean algebra for functions that return a logical 
function. Implement elementary algebra (<code>plus()</code>, <code>minus()</code>, <code>multiply()</code>, 
<code>divide()</code>, <code>exponentiate()</code>, <code>log()</code>) for functions that return numeric 
vectors.</p></li>
</ol>

<h4>Exercises from Computing-on-the-language.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>One important feature of <code>deparse()</code> to be aware of when programming is that 
it can return multiple strings if the input is too long. For example, the 
following call produces a vector of length two:</p>

<pre><code class="r">g(a + b + c + d + e + f + g + h + i + j + k + l + m +
  n + o + p + q + r + s + t + u + v + w + x + y + z)
</code></pre>

<p>Why does this happen? Carefully read the documentation. Can you write a
wrapper around <code>deparse()</code> so that it always returns a single string?</p></li>
<li><p>Why does <code>as.Date.default()</code> use <code>substitute()</code> and <code>deparse()</code>?
Why does <code>pairwise.t.test()</code> use them? Read the source code.</p></li>
<li><p><code>pairwise.t.test()</code> assumes that <code>deparse()</code> always returns a length one 
character vector. Can you construct an input that violates this expectation? 
What happens?</p></li>
<li><p><code>f()</code>, defined above, just calls <code>substitute()</code>. Why can&#39;t we use it
to define <code>g()</code>? In other words, what will the following code return?
First make a prediction. Then run the code and think about the results.</p>

<pre><code class="r">f &lt;- function(x) substitute(x)
g &lt;- function(x) deparse(f(x))
g(1:10)
g(x)
g(x + y ^ 2 / z + exp(a * sin(b)))
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Predict the results of the following lines of code:</p>

<pre><code class="r">eval(quote(eval(quote(eval(quote(2 + 2))))))
eval(eval(quote(eval(quote(eval(quote(2 + 2)))))))
quote(eval(quote(eval(quote(eval(quote(2 + 2)))))))
</code></pre></li>
<li><p><code>subset2()</code> has a bug if you use it with a single column data frame.
What should the following code return? How can you modify <code>subset2()</code>
so it returns the correct type of object?</p>

<pre><code class="r">sample_df2 &lt;- data.frame(x = 1:10)
subset2(sample_df2, x &gt; 8)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;subset2&quot;
</code></pre></li>
<li><p>The real subset function (<code>subset.data.frame()</code>) removes missing
values in the condition. Modify <code>subset2()</code> to do the same: drop the 
offending rows.</p></li>
<li><p>What happens if you use <code>quote()</code> instead of <code>substitute()</code> inside of
<code>subset2()</code>?</p></li>
<li><p>The second argument in <code>subset()</code> allows you to select variables. It
treats variable names as if they were positions. This allows you to do 
things like <code>subset(mtcars, , -cyl)</code> to drop the cylinder variable, or
<code>subset(mtcars, , disp:drat)</code> to select all the variables between <code>disp</code>
and <code>drat</code>. How does this work? I&#39;ve made this easier to understand by
extracting it out into its own function.</p>

<pre><code class="r">select &lt;- function(df, vars) {
  vars &lt;- substitute(vars)
  var_pos &lt;- setNames(as.list(seq_along(df)), names(df))
  pos &lt;- eval(vars, var_pos)
  df[, pos, drop = FALSE]
}
select(mtcars, -cyl)
</code></pre></li>
<li><p>What does <code>evalq()</code> do? Use it to reduce the amount of typing for the
examples above that use both <code>eval()</code> and <code>quote()</code>.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p><code>plyr::arrange()</code> works similarly to <code>subset()</code>, but instead of selecting
rows, it reorders them. How does it work? What does
<code>substitute(order(...))</code> do? Create a function that does only that
and experiment with it.</p></li>
<li><p>What does <code>transform()</code> do? Read the documentation. How does it work?
Read the source code for <code>transform.data.frame()</code>. What does
<code>substitute(list(...))</code> do?</p></li>
<li><p><code>plyr::mutate()</code> is similar to <code>transform()</code> but it applies the
transformations sequentially so that transformation can refer to columns
that were just created:</p>

<pre><code class="r">df &lt;- data.frame(x = 1:5)
transform(df, x2 = x * x, x3 = x2 * x)
plyr::mutate(df, x2 = x * x, x3 = x2 * x)
</code></pre>

<p>How does mutate work? What&#39;s the key difference between <code>mutate()</code> and
<code>transform()</code>?</p></li>
<li><p>What does <code>with()</code> do? How does it work? Read the source code for
<code>with.default()</code>. What does <code>within()</code> do? How does it work? Read the
source code for <code>within.data.frame()</code>. Why is the code so much more
complex than <code>with()</code>?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>The following R functions all use NSE. For each, describe how it uses NSE,
and read the documentation to determine its escape hatch.</p>

<ul>
<li><code>rm()</code></li>
<li><code>library()</code> and <code>require()</code></li>
<li><code>substitute()</code></li>
<li><code>data()</code></li>
<li><code>data.frame()</code></li>
</ul></li>
<li><p>Base functions <code>match.fun()</code>, <code>page()</code>, and <code>ls()</code> all try to
automatically determine whether you want standard or non-standard
evaluation. Each uses a different approach. Figure out the essence
of each approach then compare and contrast.</p></li>
<li><p>Add an escape hatch to <code>plyr::mutate()</code> by splitting it into two functions.
One function should capture the unevaluated inputs. The other should take a 
data frame and list of expressions and perform the computation.</p></li>
<li><p>What&#39;s the escape hatch for <code>ggplot2::aes()</code>? What about <code>plyr::()</code>?
What do they have in common? What are the advantages and disadvantages
of their differences?</p></li>
<li><p>The version of <code>subset2_q()</code> I presented is a simplification of real
code. Why is the following version better?</p>

<pre><code class="r">subset2_q &lt;- function(x, cond, env = parent.frame()) {
  r &lt;- eval(cond, x, env)
  x[r, ]
}
</code></pre>

<p>Rewrite <code>subset2()</code> and <code>subscramble()</code> to use this improved version.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Use <code>subs()</code> to convert the LHS to the RHS for each of the following pairs:</p>

<ul>
<li><code>a + b + c</code> -&gt; <code>a * b * c</code></li>
<li><code>f(g(a, b), c)</code> -&gt; <code>(a + b) * c</code></li>
<li><code>f(a &lt; b, c, d)</code> -&gt; <code>if (a &lt; b) c else d</code></li>
</ul></li>
<li><p>For each of the following pairs of expressions, describe why you can&#39;t
use <code>subs()</code> to convert one to the other.</p>

<ul>
<li><code>a + b + c</code> -&gt; <code>a + b * c</code></li>
<li><code>f(a, b)</code> -&gt; <code>f(a, b, c)</code></li>
<li><code>f(a, b, c)</code> -&gt; <code>f(a, b)</code></li>
</ul></li>
<li><p>How does <code>pryr::named_dots()</code> work? Read the source.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>What does the following function do? What&#39;s the escape hatch?
Do you think that this is an appropriate use of NSE?</p>

<pre><code class="r">nl &lt;- function(...) {
  dots &lt;- named_dots(...)
  lapply(dots, eval, parent.frame())
}
</code></pre></li>
<li><p>Instead of relying on promises, you can use formulas created with <code>~</code>
to explicitly capture an expression and its environment. What are the
advantages and disadvantages of making quoting explicit? How does it
impact referential transparency?</p></li>
<li><p>Read the standard non-standard evaluation rules found at
<a href="http://developer.r-project.org/nonstandard-eval.pdf">http://developer.r-project.org/nonstandard-eval.pdf</a>.</p></li>
</ol>

<h4>Exercises from extras/local.Rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p><code>local()</code> is hard to understand because it is very concise and uses
some sutble features of evaluation (including non-standard evaluation
of both arguments). Confirm that the following function works the same
as <code>local()</code> and then explain how it works.</p>

<pre><code class="r">local3 &lt;- function(expr, envir = new.env()) {
  call &lt;- substitute(eval(quote(expr), envir))
  env &lt;- parent.frame()

  eval(call, env)
}
</code></pre></li>
</ol>

<h4>Exercises from Expressions.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>There&#39;s no existing base function that checks if an element is
a valid component of an expression (i.e., it&#39;s a constant, name,
call, or pairlist). Implement one by guessing the names of the &ldquo;is&rdquo;
functions for calls, names, and pairlists.</p></li>
<li><p><code>pryr::ast()</code> uses non-standard evaluation. What&#39;s its escape hatch to
standard evaluation?</p></li>
<li><p>What does the call tree of an if statement with multiple else conditions
look like?</p></li>
<li><p>Compare <code>ast(x + y %+% z)</code> to <code>ast(x ^ y %+% z)</code>. What do they
tell you about the precedence of custom infix functions?</p></li>
<li><p>Why can&#39;t an expression contain an atomic vector of length greater than one?
Which one of the six types of atomic vector can&#39;t appear in an expression?
Why?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>You can use <code>formals()</code> to both get and set the arguments of a function.
Use <code>formals()</code> to modify the following function so that the default value
of <code>x</code> is missing and <code>y</code> is 10.</p>

<pre><code class="r">g &lt;- function(x = 20, y) {
  x + y
}
</code></pre></li>
<li><p>Write an equivalent to <code>get()</code> using <code>as.name()</code> and <code>eval()</code>. Write an
equivalent to <code>assign()</code> using <code>as.name()</code>, <code>substitute()</code>, and <code>eval()</code>.
(Don&#39;t worry about the multiple ways of choosing an environment; assume
that the user supplies it explicitly.)</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>The following two calls look the same, but are actually different:</p>

<pre><code class="r">(a &lt;- call(&quot;mean&quot;, 1:10))
</code></pre>

<pre><code>## mean(1:10)
</code></pre>

<pre><code class="r">(b &lt;- call(&quot;mean&quot;, quote(1:10)))
</code></pre>

<pre><code>## mean(1:10)
</code></pre>

<pre><code class="r">identical(a, b)
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>What&#39;s the difference? Which one should you prefer?</p></li>
<li><p>Implement a pure R version of <code>do.call()</code>.</p></li>
<li><p>Concatenating a call and an expression with <code>c()</code> creates a list. Implement
<code>concat()</code> so that the following code works to combine a call and
an additional argument.</p>

<pre><code class="r">concat(quote(f), a = 1, b = quote(mean(a)))
#&gt; f(a = 1, b = mean(a))
</code></pre></li>
<li><p>Since <code>list()</code>s don&#39;t belong in expressions, we could create a more
convenient call constructor that automatically combines lists into the
arguments. Implement <code>make_call()</code> so that the following code works.</p>

<pre><code class="r">make_call(quote(mean), list(quote(x), na.rm = TRUE))
#&gt; mean(x, na.rm = TRUE)
make_call(quote(mean), quote(x), na.rm = TRUE)
#&gt; mean(x, na.rm = TRUE)
</code></pre></li>
<li><p>How does <code>mode&lt;-</code> work? How does it use <code>call()</code>?</p></li>
<li><p>Read the source for <code>pryr::standardise_call()</code>. How does it work?
Why is <code>is.primitive()</code> needed?</p></li>
<li><p><code>standardise_call()</code> doesn&#39;t work so well for the following calls.
Why?</p>

<pre><code class="r">standardise_call(quote(mean(1:10, na.rm = TRUE)))
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;standardise_call&quot;
</code></pre>

<pre><code class="r">standardise_call(quote(mean(n = T, 1:10)))
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;standardise_call&quot;
</code></pre>

<pre><code class="r">standardise_call(quote(mean(x = 1:10, , TRUE)))
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;standardise_call&quot;
</code></pre></li>
<li><p>Read the documentation for <code>pryr::modify_call()</code>. How do you think
it works? Read the source code.</p></li>
<li><p>Use <code>ast()</code> and experimentation to figure out the three arguments in an
<code>if()</code> call. Which components are required? What are the arguments to
the <code>for()</code> and <code>while()</code> calls?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Compare and contrast <code>update_model()</code> with <code>update.default()</code>.</p></li>
<li><p>Why doesn&#39;t <code>write.csv(mtcars, &quot;mtcars.csv&quot;, row = FALSE)</code> work?
What property of argument matching has the original author forgotten?</p></li>
<li><p>Rewrite <code>update.formula()</code> to use R code instead of C code.</p></li>
<li><p>Sometimes it&#39;s necessary to uncover the function that called the
function that called the current function (i.e., the grandparent, not
the parent). How can you use <code>sys.call()</code> or <code>match.call()</code> to find
this function?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>How are <code>alist(a)</code> and <code>alist(a = )</code> different? Think about both the
input and the output.</p></li>
<li><p>Read the documentation and source code for <code>pryr::partial()</code>. What does it
do? How does it work? Read the documentation and source code for
<code>pryr::unenclose()</code>. What does it do and how does it work?</p></li>
<li><p>The actual implementation of <code>curve()</code> looks more like</p>

<pre><code class="r">curve3 &lt;- function(expr, xlim = c(0, 1), n = 100,
                   env = parent.frame()) {
  env2 &lt;- new.env(parent = env)
  env2$x &lt;- seq(xlim[1], xlim[2], length = n)

  y &lt;- eval(substitute(expr), env2)
  plot(env2$x, y, type = &quot;l&quot;, 
    ylab = deparse(substitute(expr)))
}
</code></pre>

<p>How does this approach differ from <code>curve2()</code> defined above?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>What are the differences between <code>quote()</code> and <code>expression()</code>?</p></li>
<li><p>Read the help for <code>deparse()</code> and construct a call that <code>deparse()</code>
and <code>parse()</code> do not operate symmetrically on.</p></li>
<li><p>Compare and contrast <code>source()</code> and <code>sys.source()</code>.</p></li>
<li><p>Modify <code>simple_source()</code> so it returns the result of <em>every</em> expression,
not just the last one.</p></li>
<li><p>The code generated by <code>simple_source()</code> lacks source references. Read
the source code for <code>sys.source()</code> and the help for <code>srcfilecopy()</code>,
then modify <code>simple_source()</code> to preserve source references. You can
test your code by sourcing a function that contains a comment. If
successful, when you look at the function, you&#39;ll see the comment and
not just the source code.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Why does <code>logical_abbr()</code> use a for loop instead of a functional
like <code>lapply()</code>?</p></li>
<li><p><code>logical_abbr()</code> works when given quoted objects, but doesn&#39;t work when
given an existing function, as in the example below. Why not? How could
you modify <code>logical_abbr()</code> to work with functions? Think about what
components make up a function.</p>

<pre><code class="r">f &lt;- function(x = TRUE) {
  g(x + T)
}
logical_abbr(f)
</code></pre></li>
<li><p>Write a function called <code>ast_type()</code> that returns either &ldquo;constant&rdquo;,
&ldquo;name&rdquo;, &ldquo;call&rdquo;, or &ldquo;pairlist&rdquo;. Rewrite <code>logical_abbr()</code>, <code>find_assign()</code>,
and <code>bquote2()</code> to use this function with <code>switch()</code> instead of nested if
statements.</p></li>
<li><p>Write a function that extracts all calls to a function. Compare your
function to <code>pryr::fun_calls()</code>.</p></li>
<li><p>Write a wrapper around <code>bquote2()</code> that does non-standard evaluation
so that you don&#39;t need to explicitly <code>quote()</code> the input.</p></li>
<li><p>Compare <code>bquote2()</code> to <code>bquote()</code>. There is a subtle bug in <code>bquote()</code>:
it won&#39;t replace calls to functions with no arguments. Why?</p>

<pre><code class="r">bquote(.(x)(), list(x = quote(f)))
</code></pre>

<pre><code>## .(x)()
</code></pre>

<pre><code class="r">bquote(.(x)(1), list(x = quote(f)))
</code></pre>

<pre><code>## f(1)
</code></pre></li>
<li><p>Improve the base <code>recurse_call()</code> template to also work with lists of
functions and expressions (e.g., as from <code>parse(path_to_file))</code>.</p></li>
</ol>

<h4>Exercises from dsl.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>The escaping rules for <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags are different: you
don&#39;t want to escape angle brackets or ampersands, but you do want to
escape <code>&lt;/script&gt;</code> or <code>&lt;/style&gt;</code>.  Adapt the code above to follow these
rules.</p></li>
<li><p>The use of <code>...</code> for all functions has some big downsides. There&#39;s no
input validation and there will be little information in the
documentation or autocomplete about how they are used in the function. 
Create a new function that, when given a named list of tags and their<br/>
attribute names (like below), creates functions which address this problem.</p>

<pre><code class="r">list(
  a = c(&quot;href&quot;),
  img = c(&quot;src&quot;, &quot;width&quot;, &quot;height&quot;)
)
</code></pre>

<p>All tags should get <code>class</code> and <code>id</code> attributes.</p></li>
<li><p>Currently the HTML doesn&#39;t look terribly pretty, and it&#39;s hard to see the
structure. How could you adapt <code>tag()</code> to do indenting and formatting?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Add escaping. The special symbols that should be escaped by adding a backslash
in front of them are <code>\</code>, <code>$</code>, and <code>%</code>. Just as with HTML, you&#39;ll need to 
make sure you don&#39;t end up double-escaping. So you&#39;ll need to create a small 
S3 class and then use that in function operators. That will also allow you 
to embed arbitrary LaTeX if needed.</p></li>
<li><p>Complete the DSL to support all the functions that <code>plotmath</code> supports.</p></li>
<li><p>There&#39;s a repeating pattern in <code>latex_env()</code>: we take a character vector,
do something to each piece, convert it to a list, and then convert the list 
to an environment. Write a function that automates this task, and then rewrite
<code>latex_env()</code>.</p></li>
<li><p>Study the source code for <code>dplyr</code>. An important part of its structure is
<code>partial_eval()</code> which helps manage expressions when some of the
components refer to variables in the database while others refer to local R
objects. Note that you could use very similar ideas if you needed to 
translate small R expressions into other languages, like JavaScript or 
Python.</p></li>
</ol>

<h4>Exercises from Performance.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>Instead of using <code>microbenchmark()</code>, you could use the built-in function
<code>system.time()</code>. But <code>system.time()</code> is much less precise, so you&#39;ll
need to repeat each operation many times with a loop, and then divide
to find the average time of each operation, as in the code below.</p>

<pre><code class="r">n &lt;- 1:1e6
system.time(for (i in n) sqrt(x)) / length(n)
system.time(for (i in n) x ^ 0.5) / length(n)
</code></pre>

<p>How do the estimates from <code>system.time()</code> compare to those from
<code>microbenchmark()</code>? Why are they different?</p></li>
<li><p>Here are two other ways to compute the square root of a vector. Which
do you think will be fastest? Which will be slowest? Use microbenchmarking
to test your answers.</p>

<pre><code class="r">x ^ (1 / 2)
exp(log(x) / 2)
</code></pre></li>
<li><p>Use microbenchmarking to rank the basic arithmetic operators (<code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>, and <code>^</code>) in terms of their speed. Visualise the results. Compare
the speed of arithmetic on integers vs. doubles.</p></li>
<li><p>You can change the units in which the microbenchmark results are
expressed with the <code>unit</code> parameter. Use <code>unit = &quot;eps&quot;</code> to show
the number of evaluations needed to take 1 second. Repeat the benchmarks
above with the eps unit. How does this change your intuition for performance?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p><code>scan()</code> has the most arguments (21) of any base function. About how
much time does it take to make 21 promises each time scan is called?
Given a simple input (e.g., <code>scan(text = &quot;1 2 3&quot;, quiet = T)</code>) what
proportion of the total run time is due to creating those promises?</p></li>
<li><p>Read <a href="http://r.cs.purdue.edu/pub/ecoop12.pdf">&ldquo;Evaluating the Design of the R Language&rdquo;</a>. What other aspects of the R-language slow it
down? Construct microbenchmarks to illustrate. </p></li>
<li><p>How does the performance of S3 method dispatch change with the length
of the class vector? How does performance of S4 method dispatch change
with number of superclasses? How about RC?</p></li>
<li><p>What is the cost of multiple inheritance and multiple dispatch on
S4 method dispatch?</p></li>
<li><p>Why is the cost of name lookup less for functions in the base package?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>The performance characteristics of <code>squish_ife()</code>, <code>squish_p()</code>, and
<code>squish_in_place()</code> vary considerably with the size of <code>x</code>. Explore the
differences. Which sizes lead to the biggest and smallest differences?</p></li>
<li><p>Compare the performance costs of extracting an element from a list, a
column from a matrix, and a column from a data frame. Do the same for rows.</p></li>
</ol>

<h4>Exercises from Profiling.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>What are faster alternatives to <code>lm</code>? Which are specifically designed 
to work with larger datasets?</p></li>
<li><p>What package implements a version of <code>match()</code> that&#39;s faster for
repeated lookups? How much faster is it?</p></li>
<li><p>List four functions (not just those in base R) that convert a string into a
date time object. What are their strengths and weaknesses?</p></li>
<li><p>How many different ways can you compute a 1d density estimate in R?</p></li>
<li><p>Which packages provide the ability to compute a rolling mean?</p></li>
<li><p>What are the alternatives to <code>optim()</code>?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>How do the results change if you compare <code>mean()</code> and <code>mean.default()</code>
on 10,000 observations, rather than on 100?</p></li>
<li><p>The following code provides an alternative implementation of <code>rowSums()</code>.
Why is it faster for this input?</p>

<pre><code class="r">rowSums2 &lt;- function(df) {
  out &lt;- df[[1L]]
  if (ncol(df) == 1) return(out)

  for (i in 2:ncol(df)) {
    out &lt;- out + df[[i]]
  }
  out
}

df &lt;- as.data.frame(
  replicate(1e3, sample(100, 1e4, replace = TRUE))
)
system.time(rowSums(df))
</code></pre>

<pre><code>##    user  system elapsed 
##    0.16    0.00    0.15
</code></pre>

<pre><code class="r">system.time(rowSums2(df))
</code></pre>

<pre><code>##    user  system elapsed 
##    0.09    0.00    0.09
</code></pre></li>
<li><p>What&#39;s the difference between <code>rowSums()</code> and <code>.rowSums()</code>?</p></li>
<li><p>Make a faster version of <code>chisq.test()</code> that only computes the chi-square
test statistic when the input is two numeric vectors with no missing
values. You can try simplifying <code>chisq.test()</code> or by coding from the 
<a href="http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test">mathematical definition</a>.</p></li>
<li><p>Can you make a faster version of <code>table()</code> for the case of an input of
two integer vectors with no missing values? Can you use it to
speed up your chi-square test?</p></li>
<li><p>Imagine you want to compute the bootstrap distribution of a sample
correlation using <code>cor_df()</code> and the data in the example below. Given that you 
want to run this many times, how can you make this code faster? (Hint: the 
function has three components that you can speed up.)</p>

<pre><code class="r">n &lt;- 1e6
df &lt;- data.frame(a = rnorm(n), b = rnorm(n))

cor_df &lt;- function(i) {
  i &lt;- sample(seq(n), n * 0.01)
  cor(q[i, , drop = FALSE])[2,1]
}
</code></pre>

<p>Is there a way to vectorise this procedure?</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>The density functions, e.g., <code>dnorm()</code>, have a common interface. Which 
arguments are vectorised over? What does <code>rnorm(10, mean = 10:1)</code> do?</p></li>
<li><p>Compare the speed of <code>apply(x, 1, sum)</code> with <code>rowSums(x)</code> for varying sizes
of <code>x</code>.</p></li>
<li><p>How can you use <code>crossprod()</code> to compute a weighted sum? How much faster is
it than the naive <code>sum(x * w)</code>?</p></li>
</ol>

<h4>Exercises from memory.rmd</h4>

<h3>Exercises</h3>

<ol>
<li><p>Repeat the analysis above for numeric, logical, and complex vectors.</p></li>
<li><p>If a data frame has one million rows, and three variables (two numeric, and 
one integer), how much space will it take up? Work it out from theory, 
then verify your work by creating a data frame and measuring its size.</p></li>
<li><p>Compare the sizes of the elements in the following two lists. Each 
contains basically the same data, but one contains vectors of small 
strings while the other contains a single long string.</p>

<pre><code class="r">vec &lt;- lapply(0:50, function(i) c(&quot;ba&quot;, rep(&quot;na&quot;, i)))
str &lt;- lapply(vec, paste0, collapse = &quot;&quot;)
</code></pre></li>
<li><p>Which takes up more memory: a factor (<code>x</code>) or the equivalent character 
vector (<code>as.character(x)</code>)? Why?</p></li>
<li><p>Explain the difference in size between <code>1:5</code> and <code>list(1:5)</code>.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>When the input is a list, we can make a more efficient <code>as.data.frame()</code> 
by using special knowledge. A data frame is a list with class <code>data.frame</code> 
and <code>row.names</code> attribute. <code>row.names</code> is either a character vector or 
vector of sequential integers, stored in a special format created by 
<code>.set_row_names()</code>. This leads to an alternative <code>as.data.frame()</code>:</p>

<pre><code class="r">to_df &lt;- function(x) {
  class(x) &lt;- &quot;data.frame&quot;
  attr(x, &quot;row.names&quot;) &lt;- .set_row_names(length(x[[1]]))
  x
}
</code></pre>

<p>What impact does this function have on <code>read_delim()</code>?  What are the 
downsides of this function?</p></li>
<li><p>Line profile the following function with <code>torture = TRUE</code>. What is 
surprising? Read the source code of <code>rm()</code> to figure out what&#39;s going on.</p>

<pre><code class="r">f &lt;- function(n = 1e5) {
  x &lt;- rep(1, n)
  rm(x)
}
</code></pre></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>The code below makes one duplication. Where does it occur and why? 
(Hint: look at <code>refs(y)</code>.)</p>

<pre><code class="r">y &lt;- as.list(x)
</code></pre>

<pre><code>## Error in as.list(x): object &#39;x&#39; not found
</code></pre>

<pre><code class="r">for(i in seq_along(medians)) {
  y[[i]] &lt;- y[[i]] - medians[i]
}
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;medians&#39; not found
</code></pre></li>
<li><p>The implementation of <code>as.data.frame()</code> in the previous section has one 
big downside. What is it and how could you avoid it?</p></li>
</ol>

<h4>Exercises from Rcpp.rmd</h4>

<h3>Exercises</h3>

<p>With the basics of C++ in hand, it&#39;s now a great time to practice by reading and writing some simple C++ functions. For each of the following functions, read the code and figure out what the corresponding base R function is. You might not understand every part of the code yet, but you should be able to figure out the basics of what the function does.</p>

<pre><code class="cpp">double f1(NumericVector x) {
  int n = x.size();
  double y = 0;

  for(int i = 0; i &lt; n; ++i) {
    y += x[i] / n;
  }
  return y;
}

NumericVector f2(NumericVector x) {
  int n = x.size();
  NumericVector out(n);

  out[0] = x[0];
  for(int i = 1; i &lt; n; ++i) {
    out[i] = out[i - 1] + x[i];
  }
  return out;
}

bool f3(LogicalVector x) {
  int n = x.size();

  for(int i = 0; i &lt; n; ++i) {
    if (x[i]) return true;
  }
  return false;
}

int f4(Function pred, List x) {
  int n = x.size();

  for(int i = 0; i &lt; n; ++i) {
    LogicalVector res = pred(x[i]);
    if (res[0]) return i + 1;
  }
  return 0;
}

NumericVector f5(NumericVector x, NumericVector y) {
  int n = std::max(x.size(), y.size());
  NumericVector x1 = rep_len(x, n);
  NumericVector y1 = rep_len(y, n);

  NumericVector out(n);

  for (int i = 0; i &lt; n; ++i) {
    out[i] = std::min(x1[i], y1[i]);
  }

  return out;
}
</code></pre>

<p>To practice your function writing skills, convert the following functions into C++. For now, assume the inputs have no missing values.</p>

<ol>
<li><p><code>all()</code></p></li>
<li><p><code>cumprod()</code>, <code>cummin()</code>, <code>cummax()</code>.</p></li>
<li><p><code>diff()</code>. Start by assuming lag 1, and then generalise for lag <code>n</code>.</p></li>
<li><p><code>range</code>.</p></li>
<li><p><code>var</code>. Read about the approaches you can take on 
<a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">wikipedia</a>.
Whenever implementing a numerical algorithm, it&#39;s always good to check what 
is already known about the problem.</p></li>
</ol>

<h3>Exercises</h3>

<ol>
<li><p>Rewrite any of the functions from the first exercise to deal with missing 
values. If <code>na.rm</code> is true, ignore the missing values. If <code>na.rm</code> is false, 
return a missing value if the input contains any missing values. Some 
good functions to practice with are <code>min()</code>, <code>max()</code>, <code>range()</code>, <code>mean()</code>, 
and <code>var()</code>.</p></li>
<li><p>Rewrite <code>cumsum()</code> and <code>diff()</code> so they can handle missing values. Note that 
these functions have slightly more complicated behaviour.</p></li>
</ol>

<h3>Exercises</h3>

<p>To practice using the STL algorithms and data structures, implement the following using R functions in C++, using the hints provided:</p>

<ol>
<li><p><code>median.default()</code> using <code>partial_sort</code>.</p></li>
<li><p><code>%in%</code> using <code>unordered_set</code> and the <code>find()</code> or <code>count()</code> methods.</p></li>
<li><p><code>unique()</code> using an <code>unordered_set</code> (challenge: do it in one line!).</p></li>
<li><p><code>min()</code> using <code>std::min()</code>, or <code>max()</code> using <code>std::max()</code>.</p></li>
<li><p><code>which.min()</code> using <code>min_element</code>, or <code>which.max()</code> using <code>max_element</code>.</p></li>
<li><p><code>setdiff()</code>, <code>union()</code>, and <code>intersect()</code> for integers using sorted ranges 
and <code>set_union</code>, <code>set_intersection</code> and <code>set_difference</code>.</p></li>
</ol>

</body>

</html>
